<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Example on how to port shadertoy to html</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="vertexShader">
      varying vec2 vUv;
      void main()
      {
          vUv = uv;

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
          gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
            uniform float iTime;
            uniform sampler2D iChannel0;
            uniform sampler2D iChannel1;
            uniform vec4      iMouse;
            uniform vec3      iResolution;

            varying vec2 vUv;

            // Maximum number of cells a ripple can cross.
      #define MAX_RADIUS 2

      // Set to 1 to hash twice. Slower, but less patterns.
      #define DOUBLE_HASH 0

      // Hash functions shamefully stolen from:
      // https://www.shadertoy.com/view/4djSRW
      #define HASHSCALE1 .1031
      #define HASHSCALE3 vec3(.1031, .1030, .0973)

      float hash12(vec2 p)
      {
      	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
          p3 += dot(p3, p3.yzx + 19.19);
          return fract((p3.x + p3.y) * p3.z);
      }

      vec2 hash22(vec2 p)
      {
      	vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);
          p3 += dot(p3, p3.yzx+19.19);
          return fract((p3.xx+p3.yz)*p3.zy);

      }

      void main(void)
      {
          float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);
      	vec2 uv = gl_FragCoord.xy / iResolution.y * resolution;
          vec2 p0 = floor(uv);

          vec2 circles = vec2(0.);
          for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)
          {
              for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)
              {
      			vec2 pi = p0 + vec2(i, j);
                  #if DOUBLE_HASH
                  vec2 hsh = hash22(pi);
                  #else
                  vec2 hsh = pi;
                  #endif
                  vec2 p = pi + hash22(hsh);

                  float t = fract(0.3*iTime + hash12(hsh));
                  vec2 v = p - uv;
                  float d = length(v) - (float(MAX_RADIUS) + 1.)*t;

                  float h = 1e-3;
                  float d1 = d - h;
                  float d2 = d + h;
                  float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);
                  float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);
                  circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));
              }
          }
          circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));

          float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));
          vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));
          vec3 color = texture(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);
      	gl_FragColor  = vec4(color, 1.0);
      }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const clock = new THREE.Clock(),
        { innerWidth, innerHeight } = window;

      var tuniform = {
        iTime: { type: "f", value: 0.1 },
        iChannel0: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/Dorset.jpg") },
        iChannel1: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/ISS.jpg") },
        iMouse: { value: new THREE.Vector2() },
        iResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
      };

      // Make sure the textures are wrapping
      tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
      tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

      // Load vertex shader and fragment shader sources
      const vertexShaderSource = document.getElementById("vertexShader").textContent;
      const fragmentShaderSource = document.getElementById("fragmentShader").textContent;

      // Create a Three.js scene
      const scene = new THREE.Scene();

      // Create a camera
      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1);
      camera.position.set(0, 0, 700);

      // Create a renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a plane to render the shader on
      const geometry = new THREE.PlaneGeometry(innerWidth, innerHeight, 1, 1);
      const material = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        side: THREE.DoubleSide,
      });
      const plane = new THREE.Mesh(geometry, material);
      scene.add(plane);

      document.addEventListener("mousemove", updateMousePosition);
      function updateMousePosition(event) {
        const { clientX, clientY } = event;
        try {
          tuniform.iMouse.value.set(clientX, clientY);
        } catch (error) {}
      }

      function render() {
        requestAnimationFrame(render);
        tuniform.iTime.value += clock.getDelta();
        renderer.render(scene, camera);
      }

      render();
    </script>
  </body>
</html>
