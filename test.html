<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Example on how to port shadertoy to html</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
    <script type="text/javascript" src=".js/utils.js"></script>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="vertexShader">
      varying vec2 vUv;
      void main()
      {
          vUv = uv;

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
          gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-fragment" id="inputFragmentValues">
      uniform float iTime;
      uniform sampler2D iChannel0;
      uniform sampler2D iChannel1;
      uniform vec4      iMouse;
      uniform vec3      iResolution;
      varying vec2 vUv;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const main = async () => {
        const clock = new THREE.Clock(),
          { innerWidth, innerHeight } = window,
          reader = new FileReader();

        var tuniform = {
          iTime: { type: "f", value: 0.1 },
          iChannel0: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/Dorset.jpg") },
          iChannel1: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/ISS.jpg") },
          iMouse: { value: new THREE.Vector2() },
          iResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
        };

        // Make sure the textures are wrapping
        tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
        tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

        // Load vertex shader and fragment shader sources
        const vertexShaderSource = document.getElementById("vertexShader").textContent;
        let fragmentShaderSource = document.getElementById("inputFragmentValues").textContent;

        await fetch("./.frag/rain.frag")
          .then((response) => response.blob())
          .then(async (blob) => {
            var reader = new FileReader();
            reader.readAsText(blob);
            while (reader.readyState != 2) await delay(100);
            fragmentShaderSource += reader.result;
          })
          .catch((error) => {
            console.error(error);
            return "";
          });

        // Create a Three.js scene
        const scene = new THREE.Scene();

        // Create a camera
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1);
        camera.position.set(0, 0, 700);

        // Create a renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a plane to render the shader on
        const geometry = new THREE.PlaneGeometry(innerWidth, innerHeight, 1, 1);
        const material = new THREE.ShaderMaterial({
          uniforms: tuniform,
          vertexShader: vertexShaderSource,
          fragmentShader: fragmentShaderSource,
          side: THREE.DoubleSide,
        });
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        document.addEventListener("mousemove", updateMousePosition);
        function updateMousePosition(event) {
          const { clientX, clientY } = event;
          try {
            tuniform.iMouse.value.set(clientX, clientY);
          } catch (error) {}
        }

        function render() {
          requestAnimationFrame(render);
          tuniform.iTime.value += clock.getDelta();
          renderer.render(scene, camera);
        }

        render();
      };
      main();
    </script>
  </body>
</html>
