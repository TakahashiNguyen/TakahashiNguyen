<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Example on how to port shadertoy to html</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="vertexShader">
      varying vec2 vUv;
      void main()
      {
          vUv = uv;

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
          gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
      uniform float iGlobalTime;
      uniform sampler2D iChannel0;
      uniform sampler2D iChannel1;

      varying vec2 vUv;

      void main(void)
      {
          vec2 p = -1.0 + 2.0 *vUv;
          vec2 q = p - vec2(0.5, 0.5);

          q.x += sin(iGlobalTime* 0.6) * 0.2;
          q.y += cos(iGlobalTime* 0.4) * 0.3;

          float len = length(q);

          float a = atan(q.y, q.x) + iGlobalTime * 0.3;
          float b = atan(q.y, q.x) + iGlobalTime * 0.3;
          float r1 = 0.3 / len + iGlobalTime * 0.5;
          float r2 = 0.2 / len + iGlobalTime * 0.5;

          float m = (1.0 + sin(iGlobalTime * 0.5)) / 2.0;
          vec4 tex1 = texture2D(iChannel0, vec2(a + 0.1 / len, r1 ));
          vec4 tex2 = texture2D(iChannel1, vec2(b + 0.1 / len, r2 ));
          vec3 col = vec3(mix(tex1, tex2, m));
          gl_FragColor = vec4(col * len * 1.5, 1.0);
      }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const clock = new THREE.Clock(),
        { innerWidth, innerHeight } = window;

      var tuniform = {
        iGlobalTime: { type: "f", value: 0.1 },
        iChannel0: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/Dorset.jpg") },
        iChannel1: { type: "t", value: THREE.ImageUtils.loadTexture("./.jpg/ISS.jpg") },
        iMouse: { value: new THREE.Vector2() },
      };

      // Make sure the textures are wrapping
      tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
      tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

      // Load vertex shader and fragment shader sources
      const vertexShaderSource = document.getElementById("vertexShader").textContent;
      const fragmentShaderSource = document.getElementById("fragmentShader").textContent;

      // Create a Three.js scene
      const scene = new THREE.Scene();

      // Create a camera
      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 700);

      // Create a renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a plane to render the shader on
      const geometry = new THREE.PlaneGeometry(innerWidth, innerHeight, 1, 1);
      const material = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: vertexShaderSource,
        fragmentShader: fragmentShaderSource,
        side: THREE.DoubleSide,
      });
      const plane = new THREE.Mesh(geometry, material);
      scene.add(plane);

      document.addEventListener("mousemove", updateMousePosition);
      function updateMousePosition(event) {
        const { clientX, clientY } = event;
        try {
          tuniform.iMouse.value.set(clientX, clientY);
        } catch (error) {}
      }

      function render() {
        requestAnimationFrame(render);
        tuniform.iGlobalTime.value += clock.getDelta();
        renderer.render(scene, camera);
      }

      render();
    </script>
  </body>
</html>
