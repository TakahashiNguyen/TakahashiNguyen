<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<style>
			body {
				margin: 0;
				overflow: hidden;
				width: 100dvw;
				height: 100dvh;
			}
			canvas {
				display: block;
			}
		</style>

		<script type="text/javascript" src=".js/utils.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	</head>
	<body id="body">
		<script>
			(async () => {
				class App {
					constructor() {
						this.clock = new THREE.Clock();
						const setDOMSize = () => {
							const { clientWidth, clientHeight } = ele("body");
							this.size = { width: clientWidth, height: clientHeight };
						};

						setDOMSize();

						this.camera = new THREE.PerspectiveCamera(1, this.size.width / this.size.height, 0.1, 1000);
						this.renderer = new THREE.WebGLRenderer();
						this.loader = new THREE.TextureLoader();
						this.mousePosition = new THREE.Vector4();
						this.counter = 0;

						// Set camera position
						this.camera.position.x = this.camera.position.y = 0;
						this.camera.position.z = 100;

						this.renderer.setSize(this.size.width, this.size.height);
						document.body.appendChild(this.renderer.domElement);

						this.renderer.domElement.addEventListener("mousedown", () => this.mousePosition.setZ(1));
						this.renderer.domElement.addEventListener("mouseup", () => this.mousePosition.setZ(0));
						this.renderer.domElement.addEventListener("mousemove", (event) => {
							this.mousePosition.setX(event.clientX);
							this.mousePosition.setY(this.size.height - event.clientY);
						});
						window.addEventListener("resize", setDOMSize);

						this.targetA = new BufferManager(this.renderer, this.size);
						this.targetB = new BufferManager(this.renderer, this.size);
						this.targetImage = new BufferManager(this.renderer, this.size);
					}

					async start() {
						const resolution = new THREE.Vector3(this.size.width, this.size.height, window.devicePixelRatio);
						const channel0 = this.loader.load(
							"https://res.cloudinary.com/di4jisedp/image/upload/v1523722553/wallpaper.jpg"
						);
						this.loader.setCrossOrigin("");

						const initBuffer = (
							fragmentShader = "",
							iChannel0 = null,
							iChannel1 = null,
							iChannel2 = null,
							iChannel3 = null
						) =>
							new BufferShader(ShaderToyToGLSL(fragmentShader), {
								iFrame: { value: 0 },
								iResolution: { value: resolution },
								iChannelResolution: { value: [resolution, resolution, resolution, resolution] },
								iMouse: { value: this.mousePosition },
								iChannel0: { value: iChannel0 },
								iChannel1: { value: iChannel1 },
								iChannel2: { value: iChannel2 },
								iChannel3: { value: iChannel3 },
								iTime: { type: "f", value: 0.1 },
							});

						await fetchFromURL("./.frag/liquify/a.frag").then((data) => (this.bufferA = initBuffer(data)));
						await fetchFromURL("./.frag/liquify/b.frag").then((data) => (this.bufferB = initBuffer(data)));
						await fetchFromURL("./.frag/liquify/image.frag").then(
							(data) => (this.bufferImage = initBuffer(data, channel0))
						);

						// Set camera look at image
						this.camera.lookAt(this.bufferImage.scene.position);

						this.animate();
					}

					animate() {
						requestAnimationFrame(() => {
							this.bufferA.uniforms.iFrame.value = this.counter++;

							this.bufferA.uniforms["iChannel0"].value = this.targetA.readBuffer.texture;
							this.bufferA.uniforms["iChannel1"].value = this.targetB.readBuffer.texture;
							this.targetA.render(this.bufferA.scene, this.camera);

							this.bufferB.uniforms["iChannel0"].value = this.targetB.readBuffer.texture;
							this.targetB.render(this.bufferB.scene, this.camera);

							this.bufferImage.uniforms["iChannel1"].value = this.targetA.readBuffer.texture;
							this.targetImage.render(this.bufferImage.scene, this.camera, true);

							this.animate();
						});
					}
				}

				class BufferShader {
					constructor(fragmentShader, uniforms = {}) {
						this.uniforms = uniforms;

						this.scene = new THREE.Scene();
						this.geometry = new THREE.PlaneBufferGeometry(2, 2);
						// this.geometry = new THREE.PlaneBufferGeometry(2, 2); !!WORKING
						this.material = new THREE.ShaderMaterial({
							fragmentShader: fragmentShader,
							vertexShader: vertexShader,
							uniforms: this.uniforms,
						});
						this.plane = new THREE.Mesh(this.geometry, this.material);

						this.plane.receiveShadow = true;
						this.plane.position.x = this.plane.position.y = this.plane.position.z = 0;

						this.scene.add(this.plane);
					}
				}

				class BufferManager {
					constructor(renderer, size) {
						this.renderer = renderer;
						this.size = size;

						this.readBuffer = new THREE.WebGLRenderTarget(size.width, size.height, {
							minFilter: THREE.LinearFilter,
							magFilter: THREE.LinearFilter,
							format: THREE.RGBAFormat,
							type: THREE.FloatType,
							stencilBuffer: false,
						});

						this.writeBuffer = this.readBuffer.clone();
					}

					swap() {
						const temp = this.readBuffer;
						this.readBuffer = this.writeBuffer;
						this.writeBuffer = temp;
					}

					render(scene, camera, toScreen = false) {
						if (toScreen) {
							this.renderer.render(scene, camera);
						} else {
							this.renderer.setRenderTarget(this.writeBuffer);
							this.renderer.clear();
							this.renderer.render(scene, camera);
							this.renderer.setRenderTarget(null);
						}

						// Dynamic sizing
						camera.aspect = this.size.width / this.size.height;
						camera.updateProjectionMatrix();
						this.renderer.setSize(this.size.width, this.size.height);

						this.swap();
					}
				}

				document.addEventListener("DOMContentLoaded", () => {
					new App().start();
				});
			})();
		</script>
	</body>
</html>
