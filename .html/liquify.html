<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<style>
			body {
				margin: 0;
				overflow: hidden;
				width: 100dvw;
				height: 100dvh;
			}
			canvas {
				display: block;
			}
		</style>

		<script type="text/javascript" src="../.js/utils.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	</head>
	<body id="body">
		<script>
			(async () => {
				class App {
					constructor() {
						this.clock = new THREE.Clock();
						this.size = new THREE.Vector2();
						this.renderer = new THREE.WebGLRenderer();
						this.loader = new THREE.TextureLoader();
						this.mousePosition = new THREE.Vector4();
						this.counter = 0;

						const setDOMSize = () => {
							const { clientWidth, clientHeight } = ele("body");
							this.size.set(clientWidth, clientHeight);
						};
						setDOMSize();

						// Setup camera
						this.camera = new THREE.PerspectiveCamera(1, this.size.width / this.size.height, 0.1, 1000);
						this.camera.position.x = this.camera.position.y = 0;
						this.camera.position.z = 100;

						// Append canvas to body
						this.renderer.setSize(this.size.width, this.size.height);
						document.body.appendChild(this.renderer.domElement);

						// Setup events
						this.renderer.domElement.addEventListener("mousedown", () => this.mousePosition.setZ(1));
						this.renderer.domElement.addEventListener("mouseup", () => this.mousePosition.setZ(0));
						this.renderer.domElement.addEventListener("mousemove", (event) => {
							this.mousePosition.setX(event.clientX);
							this.mousePosition.setY(this.size.height - event.clientY);
						});
						window.addEventListener("resize", setDOMSize);
					}

					initBuffer(isMainCamera, fragmentShader, iC0 = null, iC1 = null, iC2 = null, iC3 = null) {
						return new Buffer(
							isMainCamera,
							ShaderToyToGLSL(fragmentShader),
							this.renderer,
							this.camera,
							this.size,
							this.clock,
							{
								iFrame: { value: 0 },
								iResolution: { value: new THREE.Vector3(this.size.width, this.size.height, window.devicePixelRatio) },
								iChannelResolution: {
									value: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
								},
								iMouse: { value: this.mousePosition },
								iChannel0: { value: iC0 },
								iChannel1: { value: iC1 },
								iChannel2: { value: iC2 },
								iChannel3: { value: iC3 },
								iTime: { type: "f", value: 0.1 },
							}
						);
					}

					async start() {
						const channel0 = this.loader.load("../.jpg/ISS.jpg");
						this.loader.setCrossOrigin("");

						await fetchFromURL("../.frag/liquify/a.frag").then((data) => (this.bufferA = this.initBuffer(false, data)));
						await fetchFromURL("../.frag/liquify/b.frag").then((data) => (this.bufferB = this.initBuffer(false, data)));
						await fetchFromURL("../.frag/liquify/image.frag").then(
							(data) => (this.bufferImage = this.initBuffer(true, data, channel0))
						);

						this.animate();
					}

					animate() {
						requestAnimationFrame(() => {
							// bufferA section
							this.bufferA.uniforms.iFrame.value = this.counter++;
							this.bufferA.uniforms.iChannel0.value = this.bufferA.readBuffer.texture;
							this.bufferA.uniforms.iChannelResolution.value[0] = this.bufferA.uniforms.iResolution.value;
							this.bufferA.uniforms.iChannel1.value = this.bufferB.readBuffer.texture;
							this.bufferA.uniforms.iChannelResolution.value[1] = this.bufferB.uniforms.iResolution.value;

							// bufferB section
							this.bufferB.uniforms.iChannel0.value = this.bufferB.readBuffer.texture;
							this.bufferB.uniforms.iChannelResolution.value[0] = this.bufferB.uniforms.iResolution.value;

							// bufferImage section
							this.bufferImage.uniforms.iChannel1.value = this.bufferA.readBuffer.texture;

							// Render section
							this.bufferA.render();
							this.bufferB.render();
							this.bufferImage.render();

							this.animate();
						});
					}
				}

				class Buffer {
					constructor(isMainCamera, fragmentShader, renderer, camera, size, clock, uniforms = {}) {
						this.isMainCamera = isMainCamera;
						this.renderer = renderer;
						this.camera = camera;
						this.size = size;
						this.clock = clock;
						this.uniforms = uniforms;
						this.scene = new THREE.Scene();
						this.geometry = new THREE.PlaneBufferGeometry(size.width, size.height);
						this.material = new THREE.ShaderMaterial({
							fragmentShader: fragmentShader,
							vertexShader: vertexShader,
							uniforms: this.uniforms,
						});
						this.plane = new THREE.Mesh(this.geometry, this.material);

						this.plane.receiveShadow = true;
						this.plane.position.x = this.plane.position.y = this.plane.position.z = 0;

						this.scene.add(this.plane);

						// Buffer section
						this.readBuffer = new THREE.WebGLRenderTarget(size.width, size.height, {
							minFilter: THREE.LinearFilter,
							magFilter: THREE.LinearFilter,
							format: THREE.RGBAFormat,
							type: THREE.FloatType,
							stencilBuffer: false,
						});

						this.writeBuffer = this.readBuffer.clone();
					}

					swap() {
						const temp = this.readBuffer;
						this.readBuffer = this.writeBuffer;
						this.writeBuffer = temp;
					}

					render() {
						if (this.isMainCamera) {
							this.renderer.render(this.scene, this.camera);
							this.camera.lookAt(this.scene.position);
						} else {
							this.renderer.setRenderTarget(this.writeBuffer);
							this.renderer.clear();
							this.renderer.render(this.scene, this.camera);
							this.renderer.setRenderTarget(null);
						}

						// Dynamic sizing
						this.camera.aspect = this.size.width / this.size.height;
						this.camera.updateProjectionMatrix();
						this.uniforms.iResolution.value = new THREE.Vector3(
							this.size.width,
							this.size.height,
							window.devicePixelRatio
						);
						this.renderer.setSize(this.size.width, this.size.height);

						this.uniforms.iTime.value += this.clock.getDelta();
						this.swap();
					}
				}

				document.addEventListener("DOMContentLoaded", () => {
					new App().start();
				});
			})();
		</script>
	</body>
</html>
