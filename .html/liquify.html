<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<style>
			body {
				margin: 0;
				overflow: hidden;
				width: 100dvw;
				height: 100dvh;
			}
			canvas {
				display: block;
			}
		</style>

		<script type="text/javascript" src="../.js/utils.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	</head>
	<body id="body">
		<script>
			(async () => {
				class App {
					setDOMSize() {
						const { clientWidth, clientHeight } = this.outerElement;
						this.size.set(clientWidth, clientHeight);
					}

					constructor(element = "body") {
						return new Promise(async (resolve) => {
							if (element != "body") {
								if (isVideoEle(ele(element))) {
									while (ele(element).readyState < 2) await delay(100);
									this.mainChannel = new THREE.VideoTexture(ele(element));
								} else if (isImageEle(ele(element))) {
									while (ele(element).readyState < 2) await delay(100);
									this.mainChannel = new THREE.Texture(ele(element));
									this.mainChannel.needsUpdate = true;
								}
								var originalElement = ele(element);
								var outerDiv = document.createElement("div");
								var outerOuterDiv = document.createElement("div");

								outerDiv.setAttribute("id", `outer-${element}`);
								outerDiv.style.border = "1px solid black";
								outerDiv.style.display = "flex";
								outerDiv.style.flexDirection = "row";

								outerOuterDiv.style.display = "flex";

								originalElement.parentNode.insertBefore(outerOuterDiv, originalElement);
								//originalElement.style.opacity = "0";
								outerDiv.appendChild(originalElement);
								outerOuterDiv.appendChild(outerDiv);
							}

							// Init GLSL
							this.outerElement = ele(`outer-${element}`);
							this.size = new THREE.Vector2();
							this.renderer = new THREE.WebGLRenderer();
							this.mousePosition = new THREE.Vector4();

							this.setDOMSize();

							// Append canvas to body
							this.renderer.setSize(this.size.width, this.size.height);
							this.renderer.domElement.style.position = "fixed";
							this.outerElement.appendChild(this.renderer.domElement);

							// Setup events
							this.renderer.domElement.addEventListener("mousedown", () => this.mousePosition.setZ(1));
							this.renderer.domElement.addEventListener("mouseup", () => this.mousePosition.setZ(0));
							this.renderer.domElement.addEventListener("mousemove", (event) => {
								const rect = event.target.getBoundingClientRect();
								this.mousePosition.setX(event.clientX - rect.left);
								this.mousePosition.setY(this.size.height - event.clientY + rect.top);
							});

							resolve(this);
						});
					}

					async initBuffer(isMainCamera, fragmentShaderURL, iC0 = null, iC1 = null, iC2 = null, iC3 = null) {
						return new Buffer(
							isMainCamera,
							ShaderToyToGLSL(await fetchFromURL(fragmentShaderURL)),
							this.renderer,
							this.size,
							{
								iFrame: { value: 0 },
								iResolution: { value: new THREE.Vector3(this.size.width, this.size.height, window.devicePixelRatio) },
								iChannelResolution: {
									value: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
								},
								iMouse: { value: this.mousePosition },
								iChannel0: { value: iC0 },
								iChannel1: { value: iC1 },
								iChannel2: { value: iC2 },
								iChannel3: { value: iC3 },
								iTime: { type: "f", value: 0.1 },
							}
						);
					}

					async start() {
						//await fetchFromURL("../.frag/mario.frag").then((data) => (this.bufferMario = this.initBuffer(false, data)));
						this.bufferA = await this.initBuffer(false, "../.frag/liquify/a.frag");
						this.bufferB = await this.initBuffer(false, "../.frag/liquify/b.frag");
						this.bufferImage = await this.initBuffer(true, "../.frag/liquify/image.frag", this.mainChannel);

						this.animate();
					}

					animate() {
						requestAnimationFrame(async () => {
							// bufferA section
							this.bufferA.setChannel(0, this.bufferA);
							this.bufferA.setChannel(1, this.bufferB);

							// bufferB section
							this.bufferB.setChannel(0, this.bufferB);

							// bufferImage section
							//this.bufferImage.uniforms.iChannel0.value = this.bufferMario.readBuffer.texture;
							this.bufferImage.setChannel(1, this.bufferA);

							// Render section
							this.bufferA.render();
							this.bufferB.render();
							this.bufferImage.render();

							this.setDOMSize();
							this.animate();
						});
					}
				}

				class Buffer {
					constructor(isMainCamera, fragmentShader, renderer, size, uniforms = {}) {
						this.isMainCamera = isMainCamera;
						this.renderer = renderer;
						this.size = size;
						this.counter = 0;
						this.uniforms = uniforms;
						this.clock = new THREE.Clock();
						this.scene = new THREE.Scene();
						this.geometry = new THREE.PlaneBufferGeometry(size.width, size.height);
						this.material = new THREE.ShaderMaterial({
							fragmentShader: fragmentShader,
							vertexShader: vertexShader,
							uniforms: this.uniforms,
						});
						this.plane = new THREE.Mesh(this.geometry, this.material);

						this.plane.receiveShadow = true;
						this.plane.position.x = this.plane.position.y = this.plane.position.z = 0;

						this.scene.add(this.plane);

						// Setup camera
						this.camera = new THREE.PerspectiveCamera(1, this.size.width / this.size.height, 0.1, 1000);
						this.camera.position.x = this.camera.position.y = 0;
						this.camera.position.z = 100;

						// Buffer section
						this.readBuffer = new THREE.WebGLRenderTarget(size.width, size.height, {
							minFilter: THREE.LinearFilter,
							magFilter: THREE.LinearFilter,
							format: THREE.RGBAFormat,
							type: THREE.FloatType,
							stencilBuffer: false,
						});

						this.writeBuffer = this.readBuffer.clone();
					}

					async setChannel(number, buffer) {
						this.uniforms[`iChannel${number}`].value = buffer.readBuffer.texture;
						this.uniforms.iChannelResolution.value[number] = buffer.uniforms.iResolution.value;
					}

					async swap() {
						const temp = this.readBuffer;
						this.readBuffer = this.writeBuffer;
						this.writeBuffer = temp;
					}

					async render() {
						if (this.isMainCamera) {
							this.renderer.render(this.scene, this.camera);
							this.camera.lookAt(this.scene.position);
						} else {
							this.renderer.setRenderTarget(this.writeBuffer);
							this.renderer.clear();
							this.renderer.render(this.scene, this.camera);
							this.renderer.setRenderTarget(null);
						}

						// Dynamic sizing
						this.camera.aspect = this.size.width / this.size.height;
						this.camera.updateProjectionMatrix();
						this.uniforms.iResolution.value = new THREE.Vector3(
							this.size.width,
							this.size.height,
							window.devicePixelRatio
						);
						this.renderer.setSize(this.size.width, this.size.height);

						// Update uniforms data
						this.uniforms.iTime.value += this.clock.getDelta();
						this.uniforms.iFrame.value = this.counter++;

						this.swap();
					}
				}

				document.addEventListener("DOMContentLoaded", async () => {
					(await new App("videoChannel")).start();
					(await new App("imageChannel")).start();
				});
			})();
		</script>

		<div style="position: relative; display: flex; flex-direction: column">
			<video
				id="videoChannel"
				autoplay
				loop
				muted
				src="../.webm/greenScreenMan.webm"
				style="width: 100%; display: block"
			></video>
			<img src="../.jpg/ISS.jpg" alt="" width="500" height="500" id="imageChannel" />
		</div>
	</body>
</html>
